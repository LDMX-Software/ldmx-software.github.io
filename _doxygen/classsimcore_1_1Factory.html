<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.9.5"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>LDMX Software: simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt; Class Template Reference</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">LDMX Software
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>simcore</b></li><li class="navelem"><a class="el" href="classsimcore_1_1Factory.html">Factory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classsimcore_1_1Factory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Factory_8h_source.html">Factory.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5bc8c0ffd0630c9f18161eabd9769252"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimcore_1_1Factory.html#a5bc8c0ffd0630c9f18161eabd9769252">PrototypeMaker</a> = PrototypePtr(*)(PrototypeConstructorArgs...)</td></tr>
<tr class="separator:a5bc8c0ffd0630c9f18161eabd9769252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a05f22b732b7c2e91c456f84cc42b90b9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedType &gt; </td></tr>
<tr class="memitem:a05f22b732b7c2e91c456f84cc42b90b9"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimcore_1_1Factory.html#a05f22b732b7c2e91c456f84cc42b90b9">declare</a> ()</td></tr>
<tr class="separator:a05f22b732b7c2e91c456f84cc42b90b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad038eaa2c027b9cbf45b49ec53ff3d80"><td class="memItemLeft" align="right" valign="top">PrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimcore_1_1Factory.html#ad038eaa2c027b9cbf45b49ec53ff3d80">make</a> (const std::string &amp;full_name, PrototypeConstructorArgs... maker_args)</td></tr>
<tr class="separator:ad038eaa2c027b9cbf45b49ec53ff3d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f06c8d4ea2c8d7bba4485a9e5560e7"><td class="memTemplParams" colspan="2">template&lt;class UnaryFunction &gt; </td></tr>
<tr class="memitem:aa0f06c8d4ea2c8d7bba4485a9e5560e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimcore_1_1Factory.html#aa0f06c8d4ea2c8d7bba4485a9e5560e7">apply</a> (UnaryFunction f) const</td></tr>
<tr class="separator:aa0f06c8d4ea2c8d7bba4485a9e5560e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec82d22c81f5868c5fadb49ffe277cc"><td class="memItemLeft" align="right" valign="top"><a id="acec82d22c81f5868c5fadb49ffe277cc" name="acec82d22c81f5868c5fadb49ffe277cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Factory</b> (<a class="el" href="classsimcore_1_1Factory.html">Factory</a> const &amp;)=delete</td></tr>
<tr class="memdesc:acec82d22c81f5868c5fadb49ffe277cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete the copy constructor <br /></td></tr>
<tr class="separator:acec82d22c81f5868c5fadb49ffe277cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fcbf5173fc422d9d1103bf0f53e2c6"><td class="memItemLeft" align="right" valign="top"><a id="a45fcbf5173fc422d9d1103bf0f53e2c6" name="a45fcbf5173fc422d9d1103bf0f53e2c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsimcore_1_1Factory.html">Factory</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a45fcbf5173fc422d9d1103bf0f53e2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete the assignment operator <br /></td></tr>
<tr class="separator:a45fcbf5173fc422d9d1103bf0f53e2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abdbb8169a68e3ac620b3b296e0279e91"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsimcore_1_1Factory.html">Factory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimcore_1_1Factory.html#abdbb8169a68e3ac620b3b296e0279e91">get</a> ()</td></tr>
<tr class="separator:abdbb8169a68e3ac620b3b296e0279e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad14351915c748c3258c60b1acca42797"><td class="memItemLeft" align="right" valign="top"><a id="ad14351915c748c3258c60b1acca42797" name="ad14351915c748c3258c60b1acca42797"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Factory</b> ()=default</td></tr>
<tr class="memdesc:ad14351915c748c3258c60b1acca42797"><td class="mdescLeft">&#160;</td><td class="mdescRight">private constructor to prevent creation <br /></td></tr>
<tr class="separator:ad14351915c748c3258c60b1acca42797"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aa5ca2ad3dfebaf22d96cb3957785e66f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedType &gt; </td></tr>
<tr class="memitem:aa5ca2ad3dfebaf22d96cb3957785e66f"><td class="memTemplItemLeft" align="right" valign="top">static PrototypePtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsimcore_1_1Factory.html#aa5ca2ad3dfebaf22d96cb3957785e66f">maker</a> (PrototypeConstructorArgs... args)</td></tr>
<tr class="separator:aa5ca2ad3dfebaf22d96cb3957785e66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af867e472ad25e9a987f965931d1ea7c3"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="classsimcore_1_1Factory.html#a5bc8c0ffd0630c9f18161eabd9769252">PrototypeMaker</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimcore_1_1Factory.html#af867e472ad25e9a987f965931d1ea7c3">library_</a></td></tr>
<tr class="memdesc:af867e472ad25e9a987f965931d1ea7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">library of possible objects to create  <a href="classsimcore_1_1Factory.html#af867e472ad25e9a987f965931d1ea7c3">More...</a><br /></td></tr>
<tr class="separator:af867e472ad25e9a987f965931d1ea7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4715a1cf0d9bdae23704d8fc4c456fa0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PrototypePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimcore_1_1Factory.html#a4715a1cf0d9bdae23704d8fc4c456fa0">warehouse_</a></td></tr>
<tr class="memdesc:a4715a1cf0d9bdae23704d8fc4c456fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">warehouse of objects that have already been created  <a href="classsimcore_1_1Factory.html#a4715a1cf0d9bdae23704d8fc4c456fa0">More...</a><br /></td></tr>
<tr class="separator:a4715a1cf0d9bdae23704d8fc4c456fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Prototype, typename PrototypePtr, typename... PrototypeConstructorArgs&gt;<br />
class simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;</div><p ><a class="el" href="classsimcore_1_1Factory.html">Factory</a> to dynamically create objects derived from a specific prototype class.</p>
<p >This factory is a singleton class meaning it cannot be created by the user.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Prototype</td><td>the type of object that this factory creates. This should be the base class that all types in this factory derive from. </td></tr>
    <tr><td class="paramname">PrototypePtr</td><td>the type of pointer that the factory creates </td></tr>
    <tr><td class="paramname">PrototypeConstructorArgs</td><td>parameter pack of arguments to pass to the object constructor.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md13"></a>
Terminology</h2>
<ul>
<li><a class="el" href="classsimcore_1_1Factory.html">Factory</a>: An object that has a look-up table between class names and pointers to functions that can create them</li>
<li>Maker: A function that can create a specific class</li>
<li>Prototype: An abstract base class from which derived classes can be used</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
Design</h2>
<p >The factory itself works in two steps.</p><ol type="1">
<li>All of the different derived classes "declare" themselves so that the factory knowns how to create them. This registration is done by providing their type and the name they should be referred to by.</li>
<li>The factory creates any of the registered classes and returns a pointer to it in the form of a prototype-class pointer.</li>
</ol>
<h3><a class="anchor" id="autotoc_md15"></a>
Declaration</h3>
<p >Using an <a href="https://en.cppreference.com/w/cpp/language/namespace#Unnamed_namespaces">unnamed namespace</a> defines the variables inside it as having internal linkage and as implicitly static. Having internal linkage allows us to have repeat variable names across different source files. Being static means that the variable is guaranteed to be constructed during library load time.</p>
<p >This if we put the following code in the source file for a class deriving from our prototype, it will be declared to the factory during library load. </p><div class="fragment"><div class="line"><span class="comment">// MyDerived.cpp</span></div>
<div class="line"><span class="comment">// MyDerived inherits from MyPrototype</span></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line">  <span class="keyword">auto</span> v = ::fire::factory::Factory&lt;MyPrototype&gt;::get()</div>
<div class="line">    .declare&lt;MyDerived&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p >The details of how this is handled is documented in <a href="https://en.cppreference.com/w/cpp/language/storage_duration">Storage Class Specifiers</a>.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Usage</h2>
<p >Using the factory effecitvely can be done in situations where many classes all follow the same design structure, but have different implementations for specific steps. In order to reflect this "same design structure", we define an abstract base class for all of our derived classes from which to inherit. This abstract base class is our "prototype".</p>
<p >Below is a rudimentary example that shows you the basics of this class.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
A Prototype LibraryEntry</h3>
<p >This <code>LibraryEntry</code> prototype class satisfies our requirements. It also defines a helpful "declaration" macro for derived classes to use. </p><div class="fragment"><div class="line"><span class="comment">// LibraryEntry.hpp</span></div>
<div class="line"><span class="preprocessor">#ifndef LIBRARYENTRY_HPP</span></div>
<div class="line"><span class="preprocessor">#define LIBRARYENTRY_HPP</span></div>
<div class="line"><span class="comment">// we need the factory template</span></div>
<div class="line"><span class="preprocessor">#include &quot;Factory.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// this class is our prototype</span></div>
<div class="line"><span class="keyword">class </span>LibraryEntry {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// virtual destructor so we can dynamically create derived classes</span></div>
<div class="line">  <span class="keyword">virtual</span> ~LibraryEntry() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="comment">// pure virtual function that our derived classes will implement</span></div>
<div class="line">  <span class="keyword">virtual</span> std::string name() = 0;</div>
<div class="line">  <span class="comment">// the factory type that we will use here</span></div>
<div class="line">  <span class="keyword">using </span><a class="code hl_class" href="classsimcore_1_1Factory.html">Factory</a> = ::fire::factory::Factory&lt;LibraryEntry&gt;;</div>
<div class="line">};  <span class="comment">// LibraryEntry</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// a macro to help with registering our library entries with our factory</span></div>
<div class="line"><span class="preprocessor">#define DECLARE_LIBRARYENTRY(CLASS)                          \</span></div>
<div class="line"><span class="preprocessor">  namespace {                                                \</span></div>
<div class="line"><span class="preprocessor">    auto v = ::LibraryEntry::Factory::get().declare&lt;CLASS&gt;() \</span></div>
<div class="line"><span class="preprocessor">  }</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// LIBRARYENTRY_HPP</span></div>
<div class="ttc" id="aclasssimcore_1_1Factory_html"><div class="ttname"><a href="classsimcore_1_1Factory.html">simcore::Factory</a></div><div class="ttdef"><b>Definition:</b> <a href="Factory_8h_source.html#l00197">Factory.h:197</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18"></a>
Example Derived Classes</h3>
<p >Here are a few example derived classes.</p>
<div class="fragment"><div class="line"><span class="comment">// Book.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;LibraryEntry.hpp&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>library {</div>
<div class="line"><span class="keyword">class </span>Book : <span class="keyword">public</span> LibraryEntry {</div>
<div class="line"> public :</div>
<div class="line">  <span class="keyword">virtual</span> std::string name() final<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Where the Red Fern Grows&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">DECLARE_LIBRARYENTRY(library::Book)</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Podcast.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;LibraryEntry.hpp&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>library {</div>
<div class="line"><span class="keyword">namespace </span>audio {</div>
<div class="line"><span class="keyword">class </span>Podcast : <span class="keyword">public</span> LibraryEntry {</div>
<div class="line"> public :</div>
<div class="line">  <span class="keyword">virtual</span> std::string name() final<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;538 Politics Podcast&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">DECLARE_LIBRARYENTRY(library::audio::Podcast)</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Album.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;LibraryEntry.hpp&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>library {</div>
<div class="line"><span class="keyword">namespace </span>audio {</div>
<div class="line"><span class="keyword">class </span>Album : <span class="keyword">public</span> LibraryEntry {</div>
<div class="line"> public :</div>
<div class="line">  <span class="keyword">virtual</span> std::string name() final<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Kind of Blue&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">DECLARE_LIBRARYENTRY(library::audio::Album)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
Executable</h3>
<p >Since the <code>DECLARE_LIBRARYENTRY</code> macro defines a function that is decorated with a compiler attribute causing the function to be called at library-load time, the registration of our various library entries is automatically done before the execution of <code>main</code> (or after if the loadLibrary function is used). For simplicity, let's compile these sources files together with a main defined below.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cxx</span></div>
<div class="line"><span class="preprocessor">#include &quot;LibraryEntry.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  std::string full_cpp_name{argv[1]}; </div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keyword">auto</span> entry_ptr{LibraryEntry::Factory::get().make(full_cpp_name)};</div>
<div class="line">    std::cout &lt;&lt; entry_ptr-&gt;name() &lt;&lt; std::endl;</div>
<div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt;  e.what() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p >Compiling these files together into the <code>fave-things</code> executable would then lead to the following behavior.</p>
<div class="fragment"><div class="line">$ fave-things library::Book</div>
<div class="line">Where the Red Fern Grows</div>
<div class="line">$ fave-things library::audio::Podcast</div>
<div class="line">538 Politics Podcast</div>
<div class="line">$ fave-things library::audio::Album</div>
<div class="line">Kind of Blue</div>
<div class="line">$ fave-things library::DoesNotExist</div>
<div class="line">ERROR: An <span class="keywordtype">object</span> named library::DoesNotExist has not been declared.</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Factory_8h_source.html#l00197">197</a> of file <a class="el" href="Factory_8h_source.html">Factory.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5bc8c0ffd0630c9f18161eabd9769252" name="a5bc8c0ffd0630c9f18161eabd9769252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc8c0ffd0630c9f18161eabd9769252">&#9670;&#160;</a></span>PrototypeMaker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr , typename... PrototypeConstructorArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsimcore_1_1Factory.html">simcore::Factory</a>&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::PrototypeMaker =  PrototypePtr (*)(PrototypeConstructorArgs...)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >the signature of a function that can be used by this factory to dynamically create a new object.</p>
<p >This is merely here to make the definition of the <a class="el" href="classsimcore_1_1Factory.html">Factory</a> simpler. </p>

<p class="definition">Definition at line <a class="el" href="Factory_8h_source.html#l00205">205</a> of file <a class="el" href="Factory_8h_source.html">Factory.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa0f06c8d4ea2c8d7bba4485a9e5560e7" name="aa0f06c8d4ea2c8d7bba4485a9e5560e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f06c8d4ea2c8d7bba4485a9e5560e7">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr , typename... PrototypeConstructorArgs&gt; </div>
<div class="memtemplate">
template&lt;class UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimcore_1_1Factory.html">simcore::Factory</a>&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Apply the input UnaryFunction to each entry in the inventory</p>
<p >UnaryFunction is simply passed dirctly to std::for_each so look there for requirements upon it. </p>

<p class="definition">Definition at line <a class="el" href="Factory_8h_source.html#l00282">282</a> of file <a class="el" href="Factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  282</span>                                    {</div>
<div class="line"><span class="lineno">  283</span>    std::for_each(<a class="code hl_variable" href="classsimcore_1_1Factory.html#a4715a1cf0d9bdae23704d8fc4c456fa0">warehouse_</a>.begin(), <a class="code hl_variable" href="classsimcore_1_1Factory.html#a4715a1cf0d9bdae23704d8fc4c456fa0">warehouse_</a>.end(), f);</div>
<div class="line"><span class="lineno">  284</span>  }</div>
<div class="ttc" id="aclasssimcore_1_1Factory_html_a4715a1cf0d9bdae23704d8fc4c456fa0"><div class="ttname"><a href="classsimcore_1_1Factory.html#a4715a1cf0d9bdae23704d8fc4c456fa0">simcore::Factory::warehouse_</a></div><div class="ttdeci">std::vector&lt; PrototypePtr &gt; warehouse_</div><div class="ttdoc">warehouse of objects that have already been created</div><div class="ttdef"><b>Definition:</b> <a href="Factory_8h_source.html#l00324">Factory.h:324</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="Factory_8h_source.html#l00324">simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::warehouse_</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simulator_8cxx_source.html#l00146">simcore::Simulator::beforeNewRun()</a>, <a class="el" href="Simulator_8cxx_source.html#l00230">simcore::Simulator::produce()</a>, and <a class="el" href="RunManager_8cxx_source.html#l00053">simcore::RunManager::setupPhysics()</a>.</p>

</div>
</div>
<a id="a05f22b732b7c2e91c456f84cc42b90b9" name="a05f22b732b7c2e91c456f84cc42b90b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f22b732b7c2e91c456f84cc42b90b9">&#9670;&#160;</a></span>declare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr , typename... PrototypeConstructorArgs&gt; </div>
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classsimcore_1_1Factory.html">simcore::Factory</a>&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::declare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >register a new object to be constructible</p>
<p >We insert the new object into the library after checking that it hasn't been defined before.</p>
<dl class="section note"><dt>Note</dt><dd>This uses the demangled name of the input type as the key in our library of objects. Using the demangled name effectively assumes that all of the libraries being loaded were compiled with the same compiler version. We could undo this assumption by having the key be an input into this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedType</td><td>object type to declare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value to define a static variable to force running this function at library load time. It relates to variables so that it cannot be optimized away. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Factory_8h_source.html#l00241">241</a> of file <a class="el" href="Factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  241</span>                     {</div>
<div class="line"><span class="lineno">  242</span>    std::string full_name{boost::core::demangle(<span class="keyword">typeid</span>(DerivedType).name())};</div>
<div class="line"><span class="lineno">  243</span>    <a class="code hl_variable" href="classsimcore_1_1Factory.html#af867e472ad25e9a987f965931d1ea7c3">library_</a>[full_name] = &amp;maker&lt;DerivedType&gt;;</div>
<div class="line"><span class="lineno">  244</span>    <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>std::uintptr_t<span class="keyword">&gt;</span>(&amp;<a class="code hl_variable" href="classsimcore_1_1Factory.html#af867e472ad25e9a987f965931d1ea7c3">library_</a>);</div>
<div class="line"><span class="lineno">  245</span>  }</div>
<div class="ttc" id="aclasssimcore_1_1Factory_html_af867e472ad25e9a987f965931d1ea7c3"><div class="ttname"><a href="classsimcore_1_1Factory.html#af867e472ad25e9a987f965931d1ea7c3">simcore::Factory::library_</a></div><div class="ttdeci">std::unordered_map&lt; std::string, PrototypeMaker &gt; library_</div><div class="ttdoc">library of possible objects to create</div><div class="ttdef"><b>Definition:</b> <a href="Factory_8h_source.html#l00321">Factory.h:321</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="Factory_8h_source.html#l00321">simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::library_</a>.</p>

</div>
</div>
<a id="abdbb8169a68e3ac620b3b296e0279e91" name="abdbb8169a68e3ac620b3b296e0279e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbb8169a68e3ac620b3b296e0279e91">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr , typename... PrototypeConstructorArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsimcore_1_1Factory.html">Factory</a> &amp; <a class="el" href="classsimcore_1_1Factory.html">simcore::Factory</a>&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >get the factory instance</p>
<p >Using a static function variable gaurantees that the factory is created as soon as it is needed and that it is deleted before the program completes.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to single <a class="el" href="classsimcore_1_1Factory.html">Factory</a> instance </dd></dl>

<p class="definition">Definition at line <a class="el" href="Factory_8h_source.html#l00217">217</a> of file <a class="el" href="Factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  217</span>                        {</div>
<div class="line"><span class="lineno">  218</span>    <span class="keyword">static</span> <a class="code hl_function" href="classsimcore_1_1Factory.html#ad14351915c748c3258c60b1acca42797">Factory</a> the_factory;</div>
<div class="line"><span class="lineno">  219</span>    <span class="keywordflow">return</span> the_factory;</div>
<div class="line"><span class="lineno">  220</span>  }</div>
<div class="ttc" id="aclasssimcore_1_1Factory_html_ad14351915c748c3258c60b1acca42797"><div class="ttname"><a href="classsimcore_1_1Factory.html#ad14351915c748c3258c60b1acca42797">simcore::Factory::Factory</a></div><div class="ttdeci">Factory()=default</div><div class="ttdoc">private constructor to prevent creation</div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="Simulator_8cxx_source.html#l00146">simcore::Simulator::beforeNewRun()</a>, <a class="el" href="RunManager_8cxx_source.html#l00102">simcore::RunManager::Initialize()</a>, <a class="el" href="Simulator_8cxx_source.html#l00230">simcore::Simulator::produce()</a>, and <a class="el" href="RunManager_8cxx_source.html#l00053">simcore::RunManager::setupPhysics()</a>.</p>

</div>
</div>
<a id="ad038eaa2c027b9cbf45b49ec53ff3d80" name="ad038eaa2c027b9cbf45b49ec53ff3d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad038eaa2c027b9cbf45b49ec53ff3d80">&#9670;&#160;</a></span>make()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr , typename... PrototypeConstructorArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PrototypePtr <a class="el" href="classsimcore_1_1Factory.html">simcore::Factory</a>&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::make </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>full_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrototypeConstructorArgs...&#160;</td>
          <td class="paramname"><em>maker_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >make a new object by name</p>
<p >We look through the library to find the requested object. If found, we create one and return a pointer to the newly created object. If not found, we raise an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>if the input object name could not be found</td></tr>
  </table>
  </dd>
</dl>
<p>The arguments to the maker are determined at compiletime using the template parameters of <a class="el" href="classsimcore_1_1Factory.html">Factory</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">full_name</td><td>name of class to create, same name as passed to declare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maker_args</td><td>parameter pack of arguments to pass on to maker</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the parent class that the objects derive from. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Factory_8h_source.html#l00264">264</a> of file <a class="el" href="Factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  265</span>                                                            {</div>
<div class="line"><span class="lineno">  266</span>    <span class="keyword">auto</span> lib_it{<a class="code hl_variable" href="classsimcore_1_1Factory.html#af867e472ad25e9a987f965931d1ea7c3">library_</a>.find(full_name)};</div>
<div class="line"><span class="lineno">  267</span>    <span class="keywordflow">if</span> (lib_it == <a class="code hl_variable" href="classsimcore_1_1Factory.html#af867e472ad25e9a987f965931d1ea7c3">library_</a>.end()) {</div>
<div class="line"><span class="lineno">  268</span>      EXCEPTION_RAISE(<span class="stringliteral">&quot;SimFactory&quot;</span>,<span class="stringliteral">&quot;An object named &quot;</span>+full_name+</div>
<div class="line"><span class="lineno">  269</span>          <span class="stringliteral">&quot; has not been declared.&quot;</span>);</div>
<div class="line"><span class="lineno">  270</span>    }</div>
<div class="line"><span class="lineno">  271</span>    <a class="code hl_variable" href="classsimcore_1_1Factory.html#a4715a1cf0d9bdae23704d8fc4c456fa0">warehouse_</a>.emplace_back(lib_it-&gt;second(maker_args...));</div>
<div class="line"><span class="lineno">  272</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="classsimcore_1_1Factory.html#a4715a1cf0d9bdae23704d8fc4c456fa0">warehouse_</a>.back();</div>
<div class="line"><span class="lineno">  273</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="Factory_8h_source.html#l00321">simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::library_</a>, and <a class="el" href="Factory_8h_source.html#l00324">simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::warehouse_</a>.</p>

<p class="reference">Referenced by <a class="el" href="RunManager_8cxx_source.html#l00102">simcore::RunManager::Initialize()</a>, and <a class="el" href="RunManager_8cxx_source.html#l00053">simcore::RunManager::setupPhysics()</a>.</p>

</div>
</div>
<a id="aa5ca2ad3dfebaf22d96cb3957785e66f" name="aa5ca2ad3dfebaf22d96cb3957785e66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ca2ad3dfebaf22d96cb3957785e66f">&#9670;&#160;</a></span>maker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr , typename... PrototypeConstructorArgs&gt; </div>
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PrototypePtr <a class="el" href="classsimcore_1_1Factory.html">simcore::Factory</a>&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::maker </td>
          <td>(</td>
          <td class="paramtype">PrototypeConstructorArgs...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >make a new DerivedType returning a PrototypePtr</p>
<p >Basically a copy of what <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique"><code>std::make_unique</code></a> or <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared"><code>std::make_shared</code></a> do but with the following changes:</p><ol type="1">
<li>constructor arguments defined by the <a class="el" href="classsimcore_1_1Factory.html">Factory</a> and not here</li>
<li>return type is a base pointer and not a derived pointer</li>
</ol>
<p >This is where we required that PrototypePtr has the same behavior as STL smart pointers. The PrototypePtr class must be able to be constructed from a pointer to a derived class and must take ownership of the new object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedType</td><td>type of derived object we should create </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>constructor arguments for derived type construction </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Factory_8h_source.html#l00313">313</a> of file <a class="el" href="Factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  313</span>                                                              {</div>
<div class="line"><span class="lineno">  314</span>    <span class="keywordflow">return</span> PrototypePtr(<span class="keyword">new</span> DerivedType(std::forward&lt;PrototypeConstructorArgs&gt;(args)...));</div>
<div class="line"><span class="lineno">  315</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af867e472ad25e9a987f965931d1ea7c3" name="af867e472ad25e9a987f965931d1ea7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af867e472ad25e9a987f965931d1ea7c3">&#9670;&#160;</a></span>library_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr , typename... PrototypeConstructorArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, <a class="el" href="classsimcore_1_1Factory.html#a5bc8c0ffd0630c9f18161eabd9769252">PrototypeMaker</a>&gt; <a class="el" href="classsimcore_1_1Factory.html">simcore::Factory</a>&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::library_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>library of possible objects to create </p>

<p class="definition">Definition at line <a class="el" href="Factory_8h_source.html#l00321">321</a> of file <a class="el" href="Factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Factory_8h_source.html#l00241">simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::declare()</a>, and <a class="el" href="Factory_8h_source.html#l00264">simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::make()</a>.</p>

</div>
</div>
<a id="a4715a1cf0d9bdae23704d8fc4c456fa0" name="a4715a1cf0d9bdae23704d8fc4c456fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4715a1cf0d9bdae23704d8fc4c456fa0">&#9670;&#160;</a></span>warehouse_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prototype , typename PrototypePtr , typename... PrototypeConstructorArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PrototypePtr&gt; <a class="el" href="classsimcore_1_1Factory.html">simcore::Factory</a>&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::warehouse_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>warehouse of objects that have already been created </p>

<p class="definition">Definition at line <a class="el" href="Factory_8h_source.html#l00324">324</a> of file <a class="el" href="Factory_8h_source.html">Factory.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Factory_8h_source.html#l00282">simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::apply()</a>, and <a class="el" href="Factory_8h_source.html#l00264">simcore::Factory&lt; Prototype, PrototypePtr, PrototypeConstructorArgs &gt;::make()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SimCore/include/SimCore/<a class="el" href="Factory_8h_source.html">Factory.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
		<script src="custom.js"></script>
	</body>
</html>